// Copyright 2020-2022 Aumoa.lib. All right reserved.

#include "SourceTree.h"
#include "IO/FileReference.h"
#include "IO/Path.h"
#include "Misc/StringBuilder.h"
#include "Misc/Char.h"
#include <array>

SourceTree::SourceTree(const String& projectName, const DirectoryReference& projectDir, const DirectoryReference& intermediateDir)
	: _projectName(projectName)
	, _projectDir(projectDir)
	, _intermediateDir(intermediateDir)
{
	intermediateDir.CreateIfNotExists();
}

void SourceTree::AddDependencySourceTree(std::shared_ptr<SourceTree> sourceTree)
{
	_dependencies.emplace_back(std::move(sourceTree));
}

Task<> SourceTree::CompileAsync(std::stop_token sToken)
{
	static auto isSourceCode = [](const FileReference& fr) -> bool
	{
		return fr.CompareExtensions(TEXT(".h"));
	};

	std::vector<FileReference> sourceCodes = _projectDir.GetAllFiles(true);
	sourceCodes.clear();
	sourceCodes.emplace_back(FileReference(TEXT(R"(F:\CPP.REF\Engine\Source\Runtime\Core\Public\Object.h)")));
	//sourceCodes.emplace_back(FileReference(TEXT(R"(F:\CPP.REF\Engine\Source\Runtime\Core\Public\Type.h)")));

	std::vector<Task<>> tasks;
	for (auto& source : Linq::Where(&sourceCodes, isSourceCode))
	{
		tasks.emplace_back(Task<>::Run(std::bind(&SourceTree::CompileWorker, this, source, sToken)));
	}

	co_await Task<>::WhenAll(tasks);
}

void SourceTree::CompileWorker(const FileReference& fr, std::stop_token sToken)
{
	String textCode = fr.ReadAllText();
	std::vector<std::unique_ptr<CompiledType>> compiledTypes;

	size_t line = 1;
	for (size_t i = 0; i < textCode.length(); ++i)
	{
		if (textCode[i] == '/' && textCode.IsValidIndex(i + 1))
		{
			if (textCode[i + 1] == '/')
			{
				size_t indexOf = textCode.IndexOf(TEXT("\n"), i);
				if (indexOf == -1)
				{
					break;
				}
				i = indexOf;
				++line;
				continue;
			}
			else if (textCode[i + 1] == '*')
			{
				size_t indexOf = textCode.IndexOf(TEXT("*/"), i);
				if (indexOf == -1)
				{
					break;
				}

				indexOf += TEXT("*/").length();
				String comment = textCode.Substring(i, indexOf - i);

				line += comment.Split('\n').size() - 1;
				i = indexOf - 1;
				continue;
			}
		}

		if (textCode[i] == '\n')
		{
			++line;
			continue;
		}

		if (textCode[i] == 'S')
		{
			if (!textCode.IsValidIndex(i - 1) || Char::IsWhiteSpace(textCode[i - 1]))
			{
				static constexpr size_t length = TEXT("SCLASS()").length();
				if (textCode.SubstringView(i, length) == TEXT("SCLASS()"))
				{
					compiledTypes.emplace_back(Interpreter_SCLASS(textCode, i, line));
				}
			}
		}
	}

	if (compiledTypes.empty())
	{
		return;
	}

	String fileKey = Path::GetRelativePath(fr.GetPath(), _projectDir.GetPath());
	fileKey = String::Format(TEXT("__{}__"), fileKey
		.Replace(TEXT("/"), TEXT("_"))
		.Replace(TEXT("\\"), TEXT("_"))
		.Replace(TEXT("."), TEXT("_")));
	String generatedFileId = String::Format(TEXT("__{}_{}_GENERATED_H__"), _projectName, fileKey);

	StringBuilder generatedHeader;
	generatedHeader.AppendLine(TEXT("// Copyright 2020-2022 Aumoa.lib. All right reserved."));
	generatedHeader.AppendLine(TEXT("// Generated by NativeReflector.exe. Do NOT edit this header file."));
	generatedHeader.AppendLine();

	for (auto& ptr : compiledTypes)
	{
		ptr->Generate(generatedHeader, fileKey);
	}

	generatedHeader.AppendLine(TEXT("#undef __LIBTY_GENERATED_FILE_ID__"));
	generatedHeader.AppendLine(String::Format(TEXT("#define __LIBTY_GENERATED_FILE_ID__ {}"), fileKey));

	FileReference generatedFile = _intermediateDir.GetFile(String::Format(TEXT("{}.generated.h"), fr.GetName()));
	String previousCode = generatedFile.ReadAllText();
	if (String generatedHeaderCode = generatedHeader.ToString(); previousCode != generatedHeaderCode)
	{
		generatedFile.WriteAllText(generatedHeaderCode);
	}
}

std::unique_ptr<CompiledSCLASS> SourceTree::Interpreter_SCLASS(const String& sourceCode, size_t& indexOf, size_t& line)
{
	size_t indentLevel = 0;
	String classDeclaration;

	// Grab class declaration.
	size_t declarationIndexOf = indexOf + TEXT("SCLASS()").length();
	for (size_t i = declarationIndexOf; i < sourceCode.length(); ++i)
	{
		if (sourceCode[i] == '{')
		{
			indentLevel += 1;
		}
		else if (sourceCode[i] == '}')
		{
			indentLevel -= 1;
			if (indentLevel == -1)
			{
				throw Exception(TEXT("Unexpected '}' character."));
			}
			else if (indentLevel == 0)
			{
				classDeclaration = sourceCode.Substring(declarationIndexOf, (i + 1) - declarationIndexOf);
				indexOf = i + 1;
				break;
			}
		}
	}

	// Generate type.
	auto generatedType = std::make_unique<CompiledSCLASS>();
	generatedType->CompileSourceTree(classDeclaration, line);
	return generatedType;
}