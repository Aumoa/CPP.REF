// Copyright 2020-2023 Aumoa.lib. All right reserved.

#include "SCWApp.h"
#include "Platform/ShaderCompiler.h"
#include "Exceptions/UsageException.h"
#include "Exceptions/TerminateException.h"

ASCWApp::ASCWApp()
{
}

Task<int32> ASCWApp::RunAsync(std::stop_token InCancellationToken)
{
	String InputDirectory, OutputDirectory;
	if (CommandLine::TryGetValue(TEXT("Input"), InputDirectory) == false)
	{
		throw UsageException();
	}
	if (CommandLine::TryGetValue(TEXT("Output"), OutputDirectory) == false)
	{
		throw UsageException();
	}

	if (Directory::Exists(OutputDirectory) == false)
	{
		bool bStatus = Directory::CreateDirectory(OutputDirectory);
		check(bStatus);
	}

	auto ShaderFiles = Directory::GetFiles(InputDirectory, ESearchOption::AllDirectories)
		| Linq::Where(LP1R(p, Path::CompareExtension(p, TEXT(".hlsl"))))
		| Linq::ToVector();

	size_t AtomicIndex = 0;
	auto CompileAsync = [&]() -> Task<>
	{
		auto Compiler = NShaderCompiler::GeneratePlatformCompiler();

		static constexpr String HeaderFormatBase = TEXT(R"(
// This header file is generated by ShaderCompileWorker.
// Do NOT modify this file manually.

constexpr byte {}[] =
{{
	{}
}};
)");

		static constexpr size_t BinaryEachLine = 16;

		while (!InCancellationToken.stop_requested())
		{
			size_t Index = PlatformAtomics::InterlockedIncrement(&AtomicIndex) - 1;
			if (Index >= ShaderFiles.size())
			{
				break;
			}

			String ShaderFile = ShaderFiles[Index];
			String FileName = Path::GetFileNameWithoutExtension(ShaderFile);
			String OutputName = Path::Combine(OutputDirectory, FileName + TEXT(".fx.h"));
			std::vector<byte> Binary;

			auto Timer = PerformanceTimer::StartNew();
			if (FileName.EndsWith(TEXT("VertexShader")))
			{
				Binary = co_await Compiler->CompileVertexShaderAsync(ShaderFile, InCancellationToken);
			}
			else if (FileName.EndsWith(TEXT("PixelShader")))
			{
				Binary = co_await Compiler->CompilePixelShaderAsync(ShaderFile, InCancellationToken);
			}
			else
			{
				throw TerminateException(TerminateException::EKnownErrorCodes::NotSupportedShaderType);
			}

			std::vector<String> Lines;
			size_t Iterate = (size_t)Math::Max((int32)((Binary.size() - 1) / BinaryEachLine + 1), (int32)0);
			Lines.reserve(Iterate);

			for (size_t i = 0; i < Iterate; ++i)
			{
				size_t Start = i * BinaryEachLine;
				size_t End = Math::Min(Start + BinaryEachLine, Binary.size());
				auto Span = std::span(Binary.data() + Start, Binary.data() + End);
				Lines.emplace_back(String::Join(TEXT(", "), Span | Linq::Select(LP1R(p, String::Format(TEXT("{:>3}"), p)))));
			}

			String Body = String::Join(TEXT(",\n\t"), Lines);
			Body = String::Format(HeaderFormatBase, FileName, Body);
			co_await File::WriteAllTextAsync(OutputName, Body, InCancellationToken);

			Timer.Stop();

			Console::WriteLine(TEXT("{} ({:.2f}s)"), ShaderFile, Timer.GetElapsed().GetTotalSeconds<double>());
		}
	};

	std::vector<Task<>> Tasks;
	for (size_t i = 0; i < Thread::GetHardwareConcurrency(); ++i)
	{
		Tasks.emplace_back(CompileAsync());
	}

	co_await Task<>::WhenAll(Tasks);
	co_return 0;
}

void ASCWApp::PrintUsage(TextWriter& Writer)
{
	String Usage = TEXT(R"(Usage: 
-Input    : The source shader code directory.
-Output   : The binary code directory.
)");
	Writer.Write(Usage);
}