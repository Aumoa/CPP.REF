// Copyright 2020-2023 Aumoa.lib. All right reserved.

#include "SCWApp.h"
#include "Platform/ShaderCompiler.h"
#include "Exceptions/UsageException.h"
#include "Exceptions/TerminateException.h"
#include "Threading/CancellationToken.h"

NSCWApp::NSCWApp()
{
}

Task<> NSCWApp::RunAsync(const CancellationToken& cancellationToken)
{
	String Input, Output, Includes;
	if (CommandLine::TryGetValue(TEXT("Input"), Input) == false)
	{
		throw UsageException();
	}
	if (CommandLine::TryGetValue(TEXT("Output"), Output) == false)
	{
		throw UsageException();
	}
	CommandLine::TryGetValue(TEXT("Include"), Includes);

	std::vector<DirectoryReference> IncludesArray = Includes
		.Split(TEXT(";"), EStringSplitOptions::TrimEntries | EStringSplitOptions::RemoveEmptyEntries) |
		Linq::Select([](const String& Str) { return DirectoryReference(Str); }) |
		Linq::ToVector();

	FileReference InputFile = Input;
	DirectoryReference OutputDirectory = Output;

	if (InputFile.IsExists() == false)
	{
		throw TerminateException(TerminateException::EKnownErrorCodes::InputFileNotFound);
	}

	if (OutputDirectory.IsExists() == false)
	{
		OutputDirectory.Create();
	}

	auto Compiler = NShaderCompiler::GeneratePlatformCompiler();
	String Name = InputFile.GetName();

	NShaderCompiler::SetIncludeDirectory(IncludesArray);
	String ShaderCode = co_await InputFile.ReadAllTextAsync(cancellationToken);

	auto Timer = PerformanceTimer::StartNew();
	if (Name.EndsWith(TEXT("VertexShader")))
	{
		co_await Compiler->CompileVertexShaderAsync(InputFile.GetAbsolute(), ShaderCode, cancellationToken);
	}
	else if (Name.EndsWith(TEXT("PixelShader")))
	{
		co_await Compiler->CompilePixelShaderAsync(InputFile.GetAbsolute(), ShaderCode, cancellationToken);
	}
	else
	{
		throw TerminateException(TerminateException::EKnownErrorCodes::NotSupportedShaderType);
	}

	Timer.Stop();
	Console::WriteLine(TEXT("{} ({:.2f}s)"), InputFile.GetFileName(), Timer.GetElapsed().GetTotalSeconds<double>());

	co_await Task<>::WhenAll(
		WriteHeaderOutputAsync(Compiler.get(), OutputDirectory, Name, ShaderCode, cancellationToken),
		WriteDependencyCacheAsync(Compiler.get(), OutputDirectory, Name, cancellationToken)
	);
}

void NSCWApp::PrintUsage(TextWriter& Writer)
{
	String Usage = TEXT(R"(Usage: 
-Input    : The source shader code directory.
-Output   : The binary code directory.
)");
	Writer.Write(Usage);
}

Task<> NSCWApp::WriteHeaderOutputAsync(NShaderCompiler* Compiler, DirectoryReference OutputDirectory, String Name, String ShaderCode, const CancellationToken& cancellationToken)
{
	static constexpr size_t BinaryEachLine = 16;
	static constexpr String HeaderFormatBase = TEXT(R"(
// This header file is generated by ShaderCompileWorker.
// Do NOT modify this file manually.

#if 0
{}
#endif

constexpr byte {}[] =
{{
	{}
}};
)");

	std::span<const byte> Binary = Compiler->GetCompileResults();

	std::vector<String> Lines;
	size_t Iterate = (size_t)Math::Max((int32)((Binary.size() - 1) / BinaryEachLine + 1), (int32)0);
	Lines.reserve(Iterate);

	for (size_t i = 0; i < Iterate; ++i)
	{
		size_t Start = i * BinaryEachLine;
		size_t End = Math::Min(Start + BinaryEachLine, Binary.size());
		auto Span = std::span(Binary.data() + Start, Binary.data() + End);
		Lines.emplace_back(String::Join(TEXT(", "), Span | Linq::Select(LP1R(p, String::Format(TEXT("{:>3}"), p)))));
	}

	String Body = String::Join(TEXT(",") + Environment::NewLine + TEXT("\t"), Lines);
	Body = String::Format(HeaderFormatBase, ShaderCode, Name, Body).Replace(TEXT("\r\n"), TEXT("\n"));

	FileReference OutputFile = OutputDirectory.GetFile(Name).WithExtensions(TEXT("fx.h"));
	co_await File::CompareAndWriteAllTextAsync(OutputFile, Body, cancellationToken);
}

template<std::ranges::input_range T>
void f(T)
{
}

Task<> NSCWApp::WriteDependencyCacheAsync(NShaderCompiler* Compiler, DirectoryReference OutputDirectory, String Name, const CancellationToken& cancellationToken)
{
	using namespace Linq;

	static constexpr String DependencyFormatBase = TEXT(R"(
{{
	"includes": [
		{0}
	]
}}
)");

	auto WrapInclude = [](const FileReference& p) -> String
	{
		String AbsolutePath = p.GetAbsolutePath()
			.Replace(TEXT("\\"), TEXT("\\\\"));
		return String::Format(TEXT("\"{}\""), AbsolutePath);
	};

	String Body = String::Join(TEXT("\n        "), Compiler->GetCompilerIncludes() | Select(WrapInclude));
	FileReference OutputFile = OutputDirectory.GetFile(Name).WithExtensions(TEXT("deps.json"));
	co_await File::CompareAndWriteAllTextAsync(OutputFile, String::Format(DependencyFormatBase, Body), cancellationToken);
}