// Copyright 2020-2023 Aumoa.lib. All right reserved.

#include "Sources/HeaderSource.h"
#include "CodeAnalysis/SyntaxTree.h"
#include "CodeAnalysis/AylaCxx/AylaCxxSyntaxTree.h"
#include "CodeAnalysis/AylaCxx/AylaCxxSyntaxNode.h"
#include "CodeGen.h"

HeaderSource::HeaderSource(String InPackageName, String InPath)
	: Super(InPath)
	, PackageName(InPackageName)
{
}

HeaderSource::~HeaderSource() noexcept
{
}

Task<bool> HeaderSource::TryParseAsync(std::stop_token InCancellationToken)
{
	String Content = co_await File::ReadAllTextAsync(GetSourcePath(), InCancellationToken);
	Syntaxes = AylaCxxSyntaxTree::ParseText(Content, GetSourcePath(), InCancellationToken);
	std::vector<CodeDiagnostic> Diagnostics = Syntaxes->GetDiagnostics();
	if (Diagnostics.size() > 0)
	{
		co_return false;
	}
	co_return true;
}

std::vector<String> HeaderSource::GetErrors() const
{
	return Syntaxes->GetDiagnostics() | Linq::Select([](const CodeDiagnostic& Diag)
	{
		return Diag.ToString();
	}) | Linq::ToVector();
}

#define CHECK_SYNTAX_NODE(Node, Type, Value) \
	(Node->GetSyntaxType() == AylaCxxSyntaxNode::ESyntaxType::Type && Node->GetCode() == Value)

Task<bool> HeaderSource::CompileAsync(std::stop_token InCancellationToken)
{
	String RelativePath;
	String Prefix;
	if (GetSourcePath().StartsWith(Environment::GetEngineDirectory()))
	{
		RelativePath = Path::GetRelativePath(Environment::GetEngineDirectory(), GetSourcePath());
		Prefix = TEXT("Engine_");
	}

	FileId = Prefix + RelativePath
		.Replace(Char::ToStringView(Path::DirectorySeparatorChar), TEXT("_"))
		.Replace(TEXT("."), TEXT("_"));

	auto Nodes = Syntaxes->GetNodes() | Linq::Select([](const auto& p) { return static_cast<AylaCxxSyntaxNode*>(p.get()); }) | Linq::ToVector();
	for (size_t i = 0; i < Nodes.size(); ++i)
	{
		auto* CxxNode = Nodes[i];
		if (CHECK_SYNTAX_NODE(CxxNode, Identifier, TEXT("ACLASS")))
		{
			CompileInACLASS(ACLASSes.emplace_back(), i, Nodes);
			continue;
		}
	}

	co_return true;
}

Task<> HeaderSource::GenerateAsync(String IncludePath, String CSharpPath, std::stop_token InCancellationToken)
{
	String Filename = Path::GetFileNameWithoutExtension(GetSourcePath());
	String HeaderFilename = Path::Combine(IncludePath, Path::ChangeExtension(Filename, TEXT(".generated.h")));
	String SourceFilename = Path::Combine(IncludePath, Path::ChangeExtension(Filename, TEXT(".gen.cpp")));

	if (ACLASSes.empty())
	{
		if (File::Exists(HeaderFilename))
		{
			File::Delete(HeaderFilename);
		}
		if (File::Exists(SourceFilename))
		{
			File::Delete(SourceFilename);
		}
		co_return;
	}

	static String HeaderCode = CodeGen::HeaderComment + TEXT(R"(#pragma once

#include "ObjectMacros.h"

// GENERATED_BODY REGION
{}

#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID {}
)");

	static constexpr String SourceCode = TEXT(R"(
// This source file is generated by AylaHeaderTool.
// Do NOT modify this file manually.

#include "{}"

// BODY_IMPLEMENT REGION
{}
)");

	std::vector<String> GeneratedBodies;
	GeneratedBodies.reserve(ACLASSes.size());
	std::vector<String> BodyImplements;
	BodyImplements.reserve(ACLASSes.size());

	std::vector<Task<>> Tasks;
	String ApiName = PackageName.ToUpper() + TEXT("_API");

	for (auto& Body : ACLASSes)
	{
		String ClassNameRemovePrefix = Body.ClassName.SubstringView(1);
		static constexpr String BodyStr = TEXT(R"(
#define GENERATED_{0}_{1}_BODY \
	DECLARE_INTRINSIC_CLASS_BODY_CORE({2}, {3})

extern "C"
{{
	{4} void* NativeCall_{5}_{6}_Construct();
	{4} void* NativeCall_{5}_{6}_StaticClass();
}}

)");
		GeneratedBodies.emplace_back(String::Format(BodyStr, FileId, Body.BodyLine, Body.ClassName, Body.SuperName, ApiName, PackageName, ClassNameRemovePrefix));

		static constexpr String ImplStr = TEXT(R"(
AType* A{0}::StaticClass()
{{
	static AType* TypePtr = nullptr;
	if (TypePtr == nullptr)
	{{
		GENERATE_INTRINSIC_CLASS_METADATA({0}, {1});
		NTypeGen::GenerateClassType(TypePtr, Metadata);
	}}
	return TypePtr;
}}

extern "C"
{{
	{3} void* NativeCall_{2}_{0}_Construct()
	{{
		return NewObject<A{0}>().Drop();
	}}

	{3} void* NativeCall_{2}_{0}_StaticClass()
	{{
		return (AObject*)A{0}::StaticClass();
	}}
}}

REGISTER_INTRINSIC_CLASS(A{0}, TEXT("/Script/{2}"), A{0}::Super::StaticClass());
)");
		BodyImplements.emplace_back(String::Format(ImplStr, ClassNameRemovePrefix, TEXT("EClassMetadata::None"), PackageName, ApiName));

		static constexpr String CSharpStr = TEXT(R"(
// This class file is generated by AylaHeaderTool.
// Do NOT modify this file manually.

using System.Runtime.InteropServices;

namespace AE.{0};

public class {1} : Object
{{
    public {1}() : base(NativeCall_Construct())
    {{
    }}

    protected {1}(IntPtr nativePointer) : base(nativePointer)
    {{
    }}

    [DllImport("{0}.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "NativeCall_{0}_{1}_Construct", CharSet = CharSet.Unicode)]
    private static extern IntPtr NativeCall_Construct();

    [DllImport("{0}.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "NativeCall_{0}_{1}_StaticClass", CharSet = CharSet.Unicode)]
    private static extern IntPtr NativeCall_StaticClass();
}}
)");

		String CSharpFilename = Path::ChangeExtension(Path::Combine(CSharpPath, Body.ClassName), TEXT(".cs"));
		Tasks.emplace_back(File::CompareAndWriteAllTextAsync(CSharpFilename, String::Format(CSharpStr, PackageName, ClassNameRemovePrefix), InCancellationToken));
	}

	String SourceCodePath = GetSourcePath();
	if constexpr (Path::DirectorySeparatorChar != '/')
	{
		SourceCodePath = SourceCodePath.Replace(Char::ToStringView(Path::DirectorySeparatorChar), TEXT("/"));
	}

	Tasks.emplace_back(File::CompareAndWriteAllTextAsync(HeaderFilename, String::Format(HeaderCode, String::Join(TEXT("\n"), GeneratedBodies), FileId), InCancellationToken));
	Tasks.emplace_back(File::CompareAndWriteAllTextAsync(SourceFilename, String::Format(SourceCode, SourceCodePath, String::Join(TEXT("\n"), BodyImplements)), InCancellationToken));

	co_await Task<>::WhenAll(Tasks);
}

bool HeaderSource::CompileInACLASS(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	// ACLASS
	++Index;

	// (...)
	ParseClassAttributes(Body, Index, Nodes);

	// class API ClassName : public SuperName [, ...]
	if (ParseClassHeads(Body, Index, Nodes) == false)
	{
		return false;
	}

	size_t BodyDepth = 0;
	for (;; ++Index)
	{
		auto* CxxNode = Nodes[Index];
		if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("{")))
		{
			++BodyDepth;
			continue;
		}
		else if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("}")))
		{
			if (--BodyDepth == 0)
			{
				++Index;
				break;
			}
			continue;
		}

		if (CHECK_SYNTAX_NODE(CxxNode, Identifier, TEXT("GENERATED_BODY")))
		{
			Body.BodyLine = CxxNode->GetLineNumber();
		}
	}

	return true;
}

void HeaderSource::ParseClassAttributes(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	auto Attributes = CollectParenthesesAndStep(++Index, Nodes);
	Body.ClassAttributes = Attributes | Linq::Select([](AylaCxxSyntaxNode* p) { return p->GetCode(); }) | Linq::ToVector();
}

bool HeaderSource::ParseClassHeads(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	if (CHECK_SYNTAX_NODE(Nodes[Index + 0], Keyword, TEXT("class")) == false)
	{
		Console::Error.WriteLine(TEXT("ACLASS must be with 'class' keyword."));
		return false;
	}

	for (++Index; Index < Nodes.size(); ++Index)
	{
		if (CHECK_SYNTAX_NODE(Nodes[Index], Operator, TEXT(":")))
		{
			Body.ClassName = Nodes[Index - 1]->GetCode();
			
			if (CHECK_SYNTAX_NODE(Nodes[Index + 1], Keyword, TEXT("public")))
			{
				Body.SuperName = Nodes[Index + 2]->GetCode();
			}
			else
			{
				if (Nodes[Index + 1]->GetSyntaxType() != AylaCxxSyntaxNode::ESyntaxType::Identifier)
				{
					ReportConsoleError(Nodes[Index + 1], TEXT("Invalid inheritance."));
					return false;
				}
				Body.SuperName = Nodes[Index + 1]->GetCode();
			}
		}
		// class MODULE_API ClassName : public SuperName [, ...] {
		//                                                       ^^ here
		else if (CHECK_SYNTAX_NODE(Nodes[Index], Operator, TEXT("{")))
		{
			break;
		}
	}

	return true;
}

std::vector<AylaCxxSyntaxNode*> HeaderSource::CollectParenthesesAndStep(size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	size_t Depth = 1;
	size_t StartIndex = Index;
	while (Depth > 0)
	{
		auto* CxxNode = Nodes[Index++];
		if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT(")")))
		{
			--Depth;
			continue;
		}
		else if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("(")))
		{
			++Depth;
			continue;
		}
	}

	size_t Length = Index - StartIndex - 1;
	auto It = Nodes.begin() + StartIndex;
	return { It, It + Length };
}

void HeaderSource::ReportConsoleError(AylaCxxSyntaxNode* Node, String InMessage)
{
	Console::Error.WriteLine(TEXT("{}({},{}): {}"), GetSourcePath(), Node->GetLineNumber(), Node->GetColumnNumber(), InMessage);
}

#undef CHECK_SYNTAX_NODE