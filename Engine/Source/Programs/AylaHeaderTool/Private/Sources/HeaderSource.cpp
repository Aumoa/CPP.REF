// Copyright 2020-2023 Aumoa.lib. All right reserved.

#include "Sources/HeaderSource.h"
#include "CodeAnalysis/SyntaxTree.h"
#include "CodeAnalysis/AylaCxx/AylaCxxSyntaxTree.h"
#include "CodeAnalysis/AylaCxx/AylaCxxSyntaxNode.h"

HeaderSource::HeaderSource(String InPath)
	: Super(InPath)
{
}

HeaderSource::~HeaderSource() noexcept
{
}

Task<bool> HeaderSource::TryParseAsync(std::stop_token InCancellationToken)
{
	String Content = co_await File::ReadAllTextAsync(GetSourcePath(), InCancellationToken);
	Syntaxes = AylaCxxSyntaxTree::ParseText(Content, GetSourcePath(), InCancellationToken);
	std::vector<CodeDiagnostic> Diagnostics = Syntaxes->GetDiagnostics();
	if (Diagnostics.size() > 0)
	{
		co_return false;
	}
	co_return true;
}

std::vector<String> HeaderSource::GetErrors() const
{
	return Syntaxes->GetDiagnostics() | Linq::Select([](const CodeDiagnostic& Diag)
	{
		return Diag.ToString();
	}) | Linq::ToVector();
}

#define CHECK_SYNTAX_NODE(Node, Type, Value) \
	(Node->GetSyntaxType() == AylaCxxSyntaxNode::ESyntaxType::Type && Node->GetCode() == Value)

Task<bool> HeaderSource::CompileAsync(std::stop_token InCancellationToken)
{
	String RelativePath;
	String Prefix;
	if (GetSourcePath().StartsWith(Environment::GetEngineDirectory()))
	{
		RelativePath = Path::GetRelativePath(Environment::GetEngineDirectory(), GetSourcePath());
		Prefix = TEXT("Engine_");
	}

	FileId = Prefix + RelativePath
		.Replace(Char::ToStringView(Path::DirectorySeparatorChar), TEXT("_"))
		.Replace(TEXT("."), TEXT("_"));

	auto Nodes = Syntaxes->GetNodes() | Linq::Select([](const auto& p) { return static_cast<AylaCxxSyntaxNode*>(p.get()); }) | Linq::ToVector();
	for (size_t i = 0; i < Nodes.size(); ++i)
	{
		auto* CxxNode = Nodes[i];
		if (CHECK_SYNTAX_NODE(CxxNode, Identifier, TEXT("ACLASS")))
		{
			CompileInACLASS(ACLASSes.emplace_back(), i, Nodes);
			continue;
		}
	}

	co_return true;
}

Task<> HeaderSource::GenerateAsync(String WritesTo, std::stop_token InCancellationToken)
{
	static constexpr String HeaderCode = TEXT(R"(
// This header file is generated by AylaHeaderTool.
// Do NOT modify this file manually.

#pragma once

#include "ObjectMacros.h"

// GENERATED_BODY REGION
{}

#undef CURRENT_FILE_ID
#define CURRENT_FILE_ID {}
)");

	static constexpr String SourceCode = TEXT(R"(
// This source file is generated by AylaHeaderTool.
// Do NOT modify this file manually.

#include "{}"

// BODY_IMPLEMENT REGION
{}
)");

	std::vector<String> GeneratedBodies;
	GeneratedBodies.reserve(ACLASSes.size());
	std::vector<String> BodyImplements;
	BodyImplements.reserve(ACLASSes.size());

	for (auto& Body : ACLASSes)
	{
		static constexpr String BodyStr = TEXT(R"(
#define GENERATED_{}_{}_BODY \
	DECLARE_INTRINSIC_CLASS_BODY_CORE({}, {})

)");
		GeneratedBodies.emplace_back(String::Format(BodyStr, FileId, Body.BodyLine, Body.ClassName, Body.SuperName));

		static constexpr String ImplStr = TEXT(R"(
AType* A{0}::StaticClass()
{{
	static AType* TypePtr = nullptr;
	if (TypePtr == nullptr)
	{{
		GENERATE_INTRINSIC_CLASS_METADATA({0}, {1});
		NTypeGen::GenerateClassType(TypePtr, Metadata);
	}}
	return TypePtr;
}}
)");
		BodyImplements.emplace_back(String::Format(ImplStr, Body.ClassName.SubstringView(1), TEXT("EClassMetadata::None")));
	}

	String Filename = Path::GetFileNameWithoutExtension(GetSourcePath());
	String HeaderFilename = Path::Combine(WritesTo, Path::ChangeExtension(Filename, TEXT(".generated.h")));
	String SourceFilename = Path::Combine(WritesTo, Path::ChangeExtension(Filename, TEXT(".gen.cpp")));

	String IncludePath = GetSourcePath();
	if constexpr (Path::DirectorySeparatorChar != '/')
	{
		IncludePath = IncludePath.Replace(Char::ToStringView(Path::DirectorySeparatorChar), TEXT("/"));
	}

	co_await File::WriteAllTextAsync(HeaderFilename, String::Format(HeaderCode, String::Join(TEXT("\n"), GeneratedBodies), FileId));
	co_await File::WriteAllTextAsync(SourceFilename, String::Format(SourceCode, IncludePath, String::Join(TEXT("\n"), BodyImplements)));
}

bool HeaderSource::CompileInACLASS(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	// ACLASS
	++Index;

	// (...)
	ParseClassAttributes(Body, Index, Nodes);

	// class API ClassName : public SuperName [, ...]
	if (ParseClassHeads(Body, Index, Nodes) == false)
	{
		return false;
	}

	size_t BodyDepth = 0;
	for (;; ++Index)
	{
		auto* CxxNode = Nodes[Index];
		if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("{")))
		{
			++BodyDepth;
			continue;
		}
		else if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("}")))
		{
			if (--BodyDepth == 0)
			{
				++Index;
				break;
			}
			continue;
		}

		if (CHECK_SYNTAX_NODE(CxxNode, Identifier, TEXT("GENERATED_BODY")))
		{
			Body.BodyLine = CxxNode->GetLineNumber();
		}
	}

	return true;
}

void HeaderSource::ParseClassAttributes(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	auto Attributes = CollectParenthesesAndStep(++Index, Nodes);
	Body.ClassAttributes = Attributes | Linq::Select([](AylaCxxSyntaxNode* p) { return p->GetCode(); }) | Linq::ToVector();
}

bool HeaderSource::ParseClassHeads(CompiledACLASS& Body, size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	if (CHECK_SYNTAX_NODE(Nodes[Index + 0], Keyword, TEXT("class")) == false)
	{
		Console::Error.WriteLine(TEXT("ACLASS must be with 'class' keyword."));
		return false;
	}

	for (++Index; Index < Nodes.size(); ++Index)
	{
		if (CHECK_SYNTAX_NODE(Nodes[Index], Operator, TEXT(":")))
		{
			Body.ClassName = Nodes[Index - 1]->GetCode();
			
			if (CHECK_SYNTAX_NODE(Nodes[Index + 1], Keyword, TEXT("public")))
			{
				Body.SuperName = Nodes[Index + 2]->GetCode();
			}
			else
			{
				if (Nodes[Index + 1]->GetSyntaxType() != AylaCxxSyntaxNode::ESyntaxType::Identifier)
				{
					ReportConsoleError(Nodes[Index + 1], TEXT("Invalid inheritance."));
					return false;
				}
				Body.SuperName = Nodes[Index + 1]->GetCode();
			}
		}
		// class MODULE_API ClassName : public SuperName [, ...] {
		//                                                       ^^ here
		else if (CHECK_SYNTAX_NODE(Nodes[Index], Operator, TEXT("{")))
		{
			break;
		}
	}

	return true;
}

std::vector<AylaCxxSyntaxNode*> HeaderSource::CollectParenthesesAndStep(size_t& Index, std::vector<AylaCxxSyntaxNode*>& Nodes)
{
	size_t Depth = 1;
	size_t StartIndex = Index;
	while (Depth > 0)
	{
		auto* CxxNode = Nodes[Index++];
		if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT(")")))
		{
			--Depth;
			continue;
		}
		else if (CHECK_SYNTAX_NODE(CxxNode, Operator, TEXT("(")))
		{
			++Depth;
			continue;
		}
	}

	size_t Length = Index - StartIndex - 1;
	auto It = Nodes.begin() + StartIndex;
	return { It, It + Length };
}

void HeaderSource::ReportConsoleError(AylaCxxSyntaxNode* Node, String InMessage)
{
	Console::Error.WriteLine(TEXT("{}({},{}): {}"), GetSourcePath(), Node->GetLineNumber(), Node->GetColumnNumber(), InMessage);
}

#undef CHECK_SYNTAX_NODE